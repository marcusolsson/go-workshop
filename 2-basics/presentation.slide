Go Fundamentals
Language Syntax

Marcus Olsson
Data Engineer
Bonnier Broadcasting
@marcusolsson

* Variables

Declaring variables

.code variables/example1.go /START DECL OMIT/,/END DECL OMIT/

Initializing variables

.code variables/example1.go /START INIT OMIT/,/END INIT OMIT/

If not explicitly initialized, variables will be initialized to their respective _zero_ _value_.

.code variables/example1.go /START ZERO OMIT/,/END ZERO OMIT/

* Variables

Type will be inferred if none is defined

.code variables/example1.go /START INFER OMIT/,/END INFER OMIT/

Since this is so common, there's even a shorthand for it

.code variables/example1.go /START SHORT OMIT/,/END SHORT OMIT/

* Exercise: variables

- Open the `variables` exercise in your editor
- Will this run? If not, why? How do we fix it?
- Try removing the `fmt.Println` line. Will it still run?

* Functions

.code functions/example1.go /^func hello/,/^}/

Arguments with same type can be written more concisely.
.code functions/example1.go /^func add/,/^}/

Multiple return values
.code functions/example1.go /^func swap/,/^}/

* Exercise: functions

- Open the `functions` exercise in your editor
- Run the following in the directory

    $ go test

- Write a function that takes a first name and last name, and returns the full name

* Pro tip: Anonymous functions

Useful for defining functions without having to name them

.play functions/example2.go /^func main/,/^}/

* If

No parentheses needed

.code if/example1.go /START IF OMIT/,/END IF OMIT/

Test multiple conditions with `else` `if` and `else`

.code if/example1.go /func review/,/^}/

* Loops

There is only one looping construct, the `for` loop
.code loops/example1.go /START FIRST OMIT/,/END FIRST OMIT/

that can also be used as a `while` loop
.code loops/example1.go /START SECOND OMIT/,/END SECOND OMIT/

Omit the condition and you have yourself an infinite loop
.code loops/example1.go /START THIRD OMIT/,/END THIRD OMIT/

* Exercise: loops

- Open the `loops` exercise in your editor
- Write a program that prints the numbers 0 to 10, except 4 and 8.

* Struct types

.code struct/example1.go /^type movie/,/^}/

Declaring `struct` variables
.code struct/example1.go /^var favoriteMovie/,/$/

Structs can be initialized using struct literals.
.code struct/example1.go /START INIT OMIT/,/END INIT OMIT/

Individual fields can be accessed using the dot (`.`) operator.
.code struct/example1.go /START GETSET OMIT/,/END GETSET OMIT/

* Methods

A method is a function with a defined _receiver_.

.code methods/example1.go /START METHOD OMIT/,/END METHOD OMIT/
.play methods/example1.go /^func main/,/^}/

* Exercise: warcry

- Open the `warcry` exercise in your editor
- Write a struct `player` with a `nickname` field
- Implement a method that returns the player's war cry as a string

* Methods

But what about _modifying_ the struct from its method?

.code methods/example2.go /rename/,/^}/
.play methods/example2.go /^func main/,/^}/

The `rename` method is being passed a _copy_ of the `user` struct.
This is not what we wanted.

* Pointers

Pointers allow you to to pass references to values within your application

A pointer is its own type

.code pointers/example1.go /START DECL OMIT/,/END DECL OMIT/

Ampersand (`&`) is used to fetch a pointer to an existing value.

.code pointers/example1.go /START REF OMIT/,/END REF OMIT/

Asterisk (`*`) is used to _dereference_ a pointer to retrieve the value.

.code pointers/example1.go /START DEREF OMIT/,/END DEREF OMIT/

* Methods (revisited)

We'll make the method receiver into a pointer instead.

.code methods/example3.go /rename/,/^}/
.play methods/example3.go /^func main/,/^}/

* Exercise: potion

- Open the `potion` exercise in your editor
- Add a new field called `health` to your player struct
- Add a method `consumePotion` that restores full health to the player

Example usage:
.play methods/example4.go /^func main/,/^}/

* Interfaces

Interfaces are sets of methods that describe _behavior_ of types.

.code interfaces/example1.go /^type notifier/,/^}/

.code interfaces/example1.go /var n/,/$/

Rather than based on the _data_ a type has, we can create abstractions based on what the type can _do_.

.code interfaces/example1.go /^func sendNotification/,/^}/

* Interfaces

Interfaces in Go are satisfied _implicitly_ (no `implements` keyword)

Meaning, `emailNotifier` doesn't actually know about any of the interfaces it satisfies

.code interfaces/example1.go /START IMPL OMIT/,/END IMPL OMIT/

* Interfaces

Any type with a method `notify()` can be passed to the `sendNotification` function

.code interfaces/example1.go /START EXAMPLE OMIT/,/END EXAMPLE OMIT/

No dependency between interface and implementation (yay!)

* Exercise: warcrier

- Open the `warcrier` exercise in your editor
- Create an interface called `warcrier` with one `warcry()` method
- Add a new struct called `enemy` that also satisfies the `warcrier` interface

* Error handling

The `error` type is a built-in interface

.code error/example1.go /type error/,/^}/

Create custom errors by implementing the `Error()` method

.code error/example1.go /START MYERROR OMIT/,/END MYERROR OMIT/

* Error handling

Errors are returned just like any other value

.code error/example1.go /func add/,/^}/

Errors are handled explicitly

.code error/example1.go /START HANDLE OMIT/,/END HANDLE OMIT/

* Defer

Have you ever forgotten to free that resource?

.code defer/example1.go /func loadConfig/,/^}/

* Defer

Use the `defer` keyword to make sure a function is called when a function exits

.code defer/example2.go /func loadConfig/,/^}/

* Pro tip: Deferring anonymous functions

Can be used for more involved clean-up work

.play defer/example3.go /func main/,/^}/

* Exercise: jump

- Open the `jump` exercise in your editor
- Add code to check if player is too tired to jump
- Handle the error by printing an excuse befitting of your player

* Arrays

An array is defined by its length and its type

.code slices/example1.go /START EX1 OMIT/,/END EX1 OMIT/

An array can also be initialized using an array literal

.code slices/example1.go /START EX2 OMIT/,/END EX2 OMIT/

The built-in function `len()` returns the length of the array

.code slices/example1.go /START EX3 OMIT/,/END EX3 OMIT/

Arrays are values, and will be copied whenever passed around

* Slices

Slices provide dynamic views into the elements of an array

.code slices/example2.go /START EX1 OMIT/,/END EX1 OMIT/

Use a slice literal to allocate the underlying array

.code slices/example2.go /START EX2 OMIT/,/END EX2 OMIT/

Use the built-in `make()` function when you know the size in advance

.code slices/example2.go /START EX3 OMIT/,/END EX3 OMIT/

In practice, slices are more commonly used than arrays

* Exercise: maximum

- Open the `maximum` exercise in your editor
- Write a function to find the largest integer in a slice

* Pro tip: Ranging over slices

The `range` keyword can be used to loop over slices

.play slices/example3.go /func main/,/^}/

* Packages

All `*.go` files within a directory is part of the same _package_ and must define the name of the package they belong to.

.code packages/example1.go /START HELLO OMIT/,/END HELLO OMIT/ HLpackage

* Importing packages

Packages need to be imported before they can be used

.code packages/example1.go /START HELLO OMIT/,/END HELLO OMIT/ HLimport

Package name is used to reference functions within that package

.code packages/example1.go /START HELLO OMIT/,/END HELLO OMIT/ HLuse

* Exporting

In order for other packages to use your function, it needs to be _exported_.

Functions (and other identifiers) are exported by uppercasing the first letter.

.code packages/example1.go /START EXPORT OMIT/,/END EXPORT OMIT/

In other words, `Hello` will be part of your package _API_

* Exporting

Functions are not the only thing we can export.

.code packages/example1.go /START STRUCT OMIT/,/END STRUCT OMIT/

* Exercise: ids

- Open the `ids` exercise in your editor
- Use the `strings` package to create URL-friendly IDs from movie titles

Hint: Check out the docs for the `ToLower`, `Fields` and `Join` functions at godoc.org.

.link https://godoc.org/strings godoc.org

* Importing third-party packages

Package needs to be in your workspace

    go get github.com/sirupsen/logrus

An import path is uniquely identified by its location in a workspace

A packages located in:

    $GOPATH/src/github.com/sirupsen/logrus    

can be imported using its relative path

    import "github.com/sirupsen/logrus"



* Exercise: packages

- Open the `calculator` exercise in your editor
- In `calc/add.go`, create an exported function that returns the sum of two integers
- In `main.go`, call the function to print out the sum of any two numbers
