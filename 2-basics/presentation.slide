Go Fundamentals
Language Syntax

Marcus Olsson
Data Engineer
Bonnier Broadcasting
@marcusolsson

* Variables

Declaring variables

.code variables/example1.go /START DECL OMIT/,/END DECL OMIT/

Initializing variables

.code variables/example1.go /START INIT OMIT/,/END INIT OMIT/

If not explicitly initialized, variables will be initialized to their respective _zero_ _value_.

.code variables/example1.go /START ZERO OMIT/,/END ZERO OMIT/

* Variables

Type will be inferred if none is defined

.code variables/example1.go /START INFER OMIT/,/END INFER OMIT/

Since this is so common, there's even a shorthand for it

.code variables/example1.go /START SHORT OMIT/,/END SHORT OMIT/

* Exercise: variables

- Open the `variables` exercise in your editor
- Will this run? If not, why? How do we fix it?
- Try removing the `fmt.Println` line. Will it still run?

* Functions

.code functions/example1.go /^func hello/,/^}/

Arguments with same type can be written more concisely.
.code functions/example1.go /^func add/,/^}/

Multiple return values
.code functions/example1.go /^func swap/,/^}/

* Exercise: functions

- Open the `functions` exercise in your editor
- Run the following in the directory

    $ go test

- Write a function that takes a first name and last name, and returns the full name

* Pro tip: Anonymous functions

Useful for defining functions without having to name them

.play functions/example2.go /^func main/,/^}/

* If

No parentheses needed

.code if/example1.go /START IF OMIT/,/END IF OMIT/

Test multiple conditions with `else` `if` and `else`

.code if/example1.go /func review/,/^}/

* Loops

There is only one looping construct, the `for` loop
.code loops/example1.go /START FIRST OMIT/,/END FIRST OMIT/

that can also be used as a `while` loop
.code loops/example1.go /START SECOND OMIT/,/END SECOND OMIT/

Omit the condition and you have yourself an infinite loop
.code loops/example1.go /START THIRD OMIT/,/END THIRD OMIT/

* Exercise: loops

- Open the `loops` exercise in your editor
- Write a program that prints all numbers between 0-10, except 4 and 8.

* Struct types

.code struct/example1.go /^type movie/,/^}/

Declaring `struct` variables
.code struct/example1.go /^var favoriteMovie/,/$/

Structs can be initialized using struct literals.
.code struct/example1.go /START INIT OMIT/,/END INIT OMIT/

Individual fields can be accessed using the dot (`.`) operator.
.code struct/example1.go /START GETSET OMIT/,/END GETSET OMIT/

* Methods

A method is a function with a defined _receiver_.

.code methods/example1.go /START METHOD OMIT/,/END METHOD OMIT/
.play methods/example1.go /^func main/,/^}/

* Exercise: warcry

- Open the `warcry` exercise in your editor
- Write a struct `player` with a `nickname` field
- Implement a method that returns the player's war cry as a string

* Methods

But what about _modifying_ the struct from its method?

.code methods/example2.go /rename/,/^}/
.play methods/example2.go /^func main/,/^}/

The `rename` method is being passed a _copy_ of the `user` struct.
This is not what we wanted.

* Pointers

Pointers allow you to to pass references to values within your application

A pointer is its own type

.code pointers/example1.go /START DECL OMIT/,/END DECL OMIT/

Ampersand (`&`) is used to fetch a pointer to an existing value.

.play pointers/example1.go /START REF OMIT/,/END REF OMIT/

Asterisk (`*`) is used to fetch, or _dereference_, the value a pointer points to.

.code pointers/example1.go /START DEREF OMIT/,/END DEREF OMIT/

* Methods (revisited)

We'll make the method receiver into a pointer instead.

.code methods/example3.go /rename/,/^}/
.play methods/example3.go /^func main/,/^}/

* Exercise: potion

- Open the `potion` exercise in your editor
- Add a new field called `health` to your player struct
- Add a method `consumePotion` that restores full health to the player

Example usage:
.play methods/example4.go /^func main/,/^}/

* Interfaces

Interfaces are sets of methods that describe _behavior_ of types

.code interfaces/example1.go /^type notifier/,/^}/

.code interfaces/example1.go /var n/,/$/

Rather than based on the _data_ a type has, we can create abstractions based on what the type can _do_

.code interfaces/example1.go /^func sendNotification/,/^}/

* Interfaces

Interfaces in Go are satisfied _implicitly_ (no `implements` keyword)

Meaning, `emailNotifier` doesn't actually know about any of the interfaces it satisfies

.code interfaces/example1.go /START IMPL OMIT/,/END IMPL OMIT/

* Interfaces

Any type with a method `notify()` can be passed to the `sendNotification` function

.code interfaces/example1.go /START EXAMPLE OMIT/,/END EXAMPLE OMIT/

No dependency between interface and implementation (yay!)

* Exercise: warcrier

- Open the `warcrier` exercise in your editor
- Create an interface called `warcrier` with one `warcry()` method
- Add a new struct called `enemy` that also satisfies the `warcrier` interface

* Error handling

The `error` type is a built-in interface

.code error/example1.go /type error/,/^}/

Create custom errors by implementing the `Error()` method

.code error/example1.go /START MYERROR OMIT/,/END MYERROR OMIT/

* Error handling

Errors are returned just like any other value

.code error/example1.go /func add/,/^}/

Errors are handled explicitly

.code error/example1.go /START HANDLE OMIT/,/END HANDLE OMIT/

* Defer

Have you ever forgot to free that resource?

.code defer/example1.go /func loadConfig/,/^}/

* Defer

Use the `defer` keyword to make sure a function is called when a function exits

.code defer/example2.go /func loadConfig/,/^}/

* Pro tip: Deferring anonymous functions

Can be used for more involved clean up work

.play defer/example3.go /func main/,/^}/

* Exercise: jump

- Open the `jump` exercise in your editor
- Add code to check if player is to tired to jump
- Handle the error by printing an excuse befitting of your player

* Arrays

Arrays are defined by its length and its type

.code slices/example1.go /func example1/,/^}/

Arrays can be declared and initialized at the same time

.code slices/example1.go /func example2/,/^}/

* Slices

Slices provide dynamic views into the elements of an array

.play slices/example2.go /func main/,/^}/

In practice, slices are more commonly used than arrays

* Slices

Use the built-in function `len()` to check the size of any slice or array

.play slices/example4.go /func main/,/^}/

* Exercise: maximum

- Open the `maximum` exercise in your editor
- Write a function to find the maximum integer in a slice

* Slices

The `range` keyword can be used to loop over slices

.play slices/example3.go /func main/,/^}/

* Maps

Declaring a map

.code maps/example1.go /var customers/,/int/

Initialize a map using `make`

.code maps/example1.go /var customers/,/int/

or by using a literal

.code maps/example1.go /customers = map/,/}/

* Maps

Elements can be accessed using the `[]` operator
.code maps/example1.go /v := customers/,/]/

If key didn't exist, the zero value of that type will be returned

Check if element exists
.code maps/example1.go /v, ok/,/}/

You can check the length of a map using the `len()` function

* Packages

All `*.go` files within a directory is part of the same _package_ and must define the name of the package they belong to.

.code packages/example1.go /START HELLO OMIT/,/END HELLO OMIT/ HLpackage

* Packages

Packages need to be imported before they can be used.

.code packages/example1.go /START HELLO OMIT/,/END HELLO OMIT/ HLimport

Package name is used to reference functions within that package.

.code packages/example1.go /START HELLO OMIT/,/END HELLO OMIT/ HLuse

* Exporting

In order for other packages to use your function, it needs to be _exported_.

Functions (and other identifiers) are exported by uppercasing the first letter.

.code packages/example1.go /START EXPORT OMIT/,/END EXPORT OMIT/

In other words, `Hello` will be part of your package _API_.

* Exporting

Functions are not the only thing we can export.

.code packages/example1.go /START STRUCT OMIT/,/END STRUCT OMIT/

* Exercise: packages

- Open the `packages` exercise in your editor
- In `calc/add.go`, create an exported function that returns the sum of two integers
- In `main.go`, call the function to print out the sum of any two numbers
